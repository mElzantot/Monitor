

#include <iostream>
#include <gl/glew/glew.h>
#include <SFML/Graphics.hpp>
#include <SFML/OpenGL.hpp>
#include<gl\glm\glm.hpp>
#include<gl\glm\gtc\type_ptr.hpp>
#include<gl\glm\gtx\transform.hpp>
#include<vector>

using namespace std;
using namespace glm;

const GLint WIDTH = 600, HEIGHT = 600;
GLuint VAO, VBO, programId, IBO;
GLuint modelMatLoc, viewMatLoc, projMatLoc;
GLuint InitShader(const char* vertex_shader_file_name, const char* fragment_shader_file_name);


glm::vec3 G_Up = glm::vec3(0.0f, 1.0f, 0.0f);
glm::vec3 cameraPosition(0.0f, 0.0f, 3.0f);
glm::vec3 cameraDirection(0, 0, -1);
glm::vec3 cameraRight = glm::normalize(cross(G_Up,cameraDirection));
glm::vec3 cameraUP= glm::normalize(cross( cameraDirection, cameraRight));


 

struct vertex
{
	vec3 position;
	vec3 color;
	vertex() {}
	vertex(vec3 _position, vec3 _color) :position{ _position }, color{ _color }
	{
	}
	vertex(vec3 _position) :position{ _position }, color(0, 0, 0)
	{
	}
};

vertex cube_core_vertices[] = {
{vec3(-0.5, 0.5, 0.5),vec3(1,0,0)},
{vec3(-0.5, -0.5, 0.5),vec3(1,0,0) },
{vec3(0.5, -0.5, 0.5),vec3(1,0,0)},
{vec3(0.5, 0.5, 0.5),vec3(1,0,0)},
{vec3(0.5, 0.5, -0.5),vec3(.5,0.5,1)},
{vec3(0.5, -0.5, -0.5),vec3(0,0,0)},
{vec3(-0.5, -0.5, -0.5),vec3(.5,.5,1)},
{vec3(-0.5, 0.5, -0.5),vec3(0.9,0.9,.9)}
};

int vertices_Indeces[] = {
	//front
	0,
	1,
	2,

	0,
	2,
	3,
	//Right
	3,
	2,
	5,

	3,
	5,
	4,
	//Back
	4,
	5,
	6,

	4,
	6,
	7,
	//Left
	7,
	6,
	1,

	7,
	1,
	0,
	//Top
	7,
	0,
	3,

	7,
	3,
	4,
	//Bottom
	2,
	1,
	6,

	2,
	6,
	5
};

void createCube()
{

	glGenBuffers(1, &VBO);
	glBindBuffer(GL_ARRAY_BUFFER, VBO);
	glBufferData(GL_ARRAY_BUFFER, sizeof(cube_core_vertices), cube_core_vertices, GL_STATIC_DRAW);
	glVertexAttribPointer(0, 3, GL_FLOAT, false, sizeof(vertex), 0);
	glEnableVertexAttribArray(0);

	glVertexAttribPointer(1, 3, GL_FLOAT, false, sizeof(vertex), (char*)(sizeof(vec3)));
	glEnableVertexAttribArray(1);

	glGenBuffers(1, &IBO);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, IBO);

	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(vertices_Indeces), vertices_Indeces, GL_STATIC_DRAW);
}

void CompileShader()
{
	programId = InitShader("VS.glsl", "FS.glsl");
	glUseProgram(programId);
}

int Init()
{
	GLenum err = glewInit();


	if (err != GLEW_OK)
	{
		cout << "Error";
		getchar();
		return 1;
	}
	else
	{
		if (GLEW_VERSION_3_0)
			cout << "Driver support OpenGL 3.0\nDetails:\n";
	}
	cout << "\tUsing glew " << glewGetString(GLEW_VERSION) << endl;
	cout << "\tVendor: " << glGetString(GL_VENDOR) << endl;
	cout << "\tRenderer: " << glGetString(GL_RENDERER) << endl;
	cout << "\tVersion: " << glGetString(GL_VERSION) << endl;
	cout << "\tGLSL:" << glGetString(GL_SHADING_LANGUAGE_VERSION) << endl;

	CompileShader();

	createCube();

	modelMatLoc = glGetUniformLocation(programId, "modelMat");
	viewMatLoc = glGetUniformLocation(programId, "viewMat");
	projMatLoc = glGetUniformLocation(programId, "projectionMat");

	glClearColor(0, 0, 0, 1);

	glEnable(GL_DEPTH_TEST);

	return 0;

}


void Render()
{
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

#pragma region viewMat

	glm::mat4 view;
	
	view = glm::lookAt(cameraPosition, cameraPosition + cameraDirection, G_Up);
	glUniformMatrix4fv(viewMatLoc, 1, GL_FALSE, glm::value_ptr(view));

#pragma endregion

#pragma region projMat

	glm::mat4 projMat = glm::perspective(45.0f, 1.0f, 0.1f, 100.0f);
	glUniformMatrix4fv(projMatLoc, 1, GL_FALSE, glm::value_ptr(projMat));

#pragma endregion

#pragma region modelMat

	glm::mat4 modelMat = glm::translate(vec3(0.5, 0, 0.5)) * glm::scale(vec3(.5, .5, .5));
	glUniformMatrix4fv(modelMatLoc, 1, GL_FALSE, glm::value_ptr(modelMat));
	glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, NULL);


	modelMat = glm::translate(vec3(-0.5, 0, 0.5)) * glm::scale(vec3(.5, .5, .5));
	glUniformMatrix4fv(modelMatLoc, 1, GL_FALSE, glm::value_ptr(modelMat));
	glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, NULL);


	modelMat = glm::translate(vec3(0.5, 0, -0.5)) * glm::scale(vec3(.5, .5, .5));
	glUniformMatrix4fv(modelMatLoc, 1, GL_FALSE, glm::value_ptr(modelMat));
	glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, NULL);


	modelMat = glm::translate(vec3(-0.5, 0, -0.5)) * glm::scale(vec3(.5, .5, .5));
	glUniformMatrix4fv(modelMatLoc, 1, GL_FALSE, glm::value_ptr(modelMat));
	glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, NULL);


	modelMat = glm::translate(vec3(-0.5, -.5, 0)) * glm::scale(vec3(1, .1, 1));
	glUniformMatrix4fv(modelMatLoc, 1, GL_FALSE, glm::value_ptr(modelMat));
	glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, NULL);
#pragma endregion

}

#define STEP 0.005

int main()
{
	sf::ContextSettings context;
	context.depthBits = 24;
	sf::Window window(sf::VideoMode(WIDTH, HEIGHT), "SFML works!", sf::Style::Close, context);



	if (Init()) return 1;



	////////////////
	float xpos;
	float ypos;
	float lastX = 0, lastY = 0;
	float xoffset;
	float yoffset;
	const float sensitivity = 0.05f;
	float yaw = -1.5707963, pitch=0;
	BOOL firstMouse = TRUE;
	glm::vec3 direction;
	/////////////////////////



	while (window.isOpen())
	{

		sf::Event event;

		while (window.pollEvent(event))
		{
			switch (event.type)
			{
			case sf::Event::Closed:
				window.close();
				break;
			case sf::Event::KeyPressed:
				switch (event.key.code)
				{
				case(sf::Keyboard::Escape):
					window.close();
					break;



				case(sf::Keyboard::Up):
					cameraPosition += cameraUP * .05f;
					break;
				case(sf::Keyboard::Down):
					cameraPosition -= cameraUP * .05f;
					break;


				case(sf::Keyboard::Right):
					cameraPosition -= cameraRight*.05f;
					break;
				case(sf::Keyboard::Left):
					cameraPosition += cameraRight *.05f;
					break;


				case(sf::Keyboard::F):
					cameraPosition += cameraDirection * 0.05f;
					break;
				case(sf::Keyboard::B):
					cameraPosition -= cameraDirection * 0.05f;
					break;

				case(sf::Keyboard::W):
					pitch += STEP;
			
					break;
				case(sf::Keyboard::S):
					pitch -= STEP;
			
					break;


				case(sf::Keyboard::D):
					yaw += STEP;
					
					break;
				case(sf::Keyboard::A):
					yaw -= STEP;
				
					break;
				}
				
				direction.x = cos(yaw) * cos(pitch);
				direction.y = sin(pitch);
				direction.z = sin(yaw) * cos(pitch);
				cameraDirection = glm::normalize(direction);
				
				cout << endl<<direction.x << endl;
				cout << direction.y << endl;
				cout << direction.z << endl;
				cout << cameraDirection.x<<" , "<< cameraDirection.y<<" , "<< cameraDirection.z << endl;
				direction.y = sin(pitch);
				
				break;



			case sf::Event::MouseButtonPressed:
				switch (event.mouseButton.button)
				{
				case sf::Mouse::Left:
					xpos = (2 * sf::Mouse::getPosition(window).x / 600) + 1;
					ypos = (-2 * sf::Mouse::getPosition(window).y / 600) - 1;
					cout << xpos << endl;
					cout << ypos << endl;


					xoffset = xpos - lastX;
					yoffset = lastY - ypos;

					xoffset *= sensitivity;
					yoffset *= sensitivity;

					cameraDirection.x += xoffset;
					cameraDirection.y += yoffset;

					



					//yaw += xoffset;
					//pitch += yoffset;

					//if (pitch > 89.0f)
					//	pitch = 89.0f;
					//if (pitch < -89.0f)
					//	pitch = -89.0f;

					//glm::vec3 direction;
					//direction.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));
					//direction.y = sin(glm::radians(pitch));
					//direction.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));
					///*cameraFront = glm::normalize(direction);*/



				}
			}
		}

		


		Render();
		window.display();
	}

	return 0;
}

//
//void di() {
//	float yaw=-90.0f , pitch;
//	glm::vec3 direction;
//	direction.x = cos(yaw)* cos(pitch);
//	direction.z = sin(yaw) * cos(pitch);
//	direction.y = sin(pitch);
//}